---
layout: default
---

<br/>

<div class="article">
    <div class="panel">
	    <div class="panel-body" style="padding: 15px 55px;">

	        <h1>backbone.hateoas <small>HATEOAS with Backbone</small></h1>
	        <p>
	            <img src="https://img.shields.io/travis/gomoob/backbone.hateoas.svg" />
	            <img src="https://img.shields.io/coveralls/gomoob/backbone.hateoas.svg" />
	            <img src="https://img.shields.io/github/release/gomoob/backbone.hateoas.svg" />
	        </p>
            <p>
	            backbone.hateoas is a Javascript library which facilitates the use of 
	            <a href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a> (Hypermedia as the Engine of Application 
	            State) and the HAL (Hypertext Application Language) standard in your Backbone and Marionette 
	            applications.
            </p>
            <p>
                To understand what is HATEAOS and what's its place in REST in general we advise you to understand the 
                <a href="http://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model</a> 
                and most specifically the 
                <a href="http://martinfowler.com/articles/richardsonMaturityModel.html#level3">REST Level 3 - Hypermedia 
                Controls</a>.
            </p>
            <p>
                Today several standards exists to model REST resources and links between them - 
                <a href="http://stateless.co/hal_specification.html">HAL</a>, 
                <a href="http://www.w3.org/TR/json-ld">JSON-LD</a>, 
                <a href="http://amundsen.com/media-types/collection/">Collection+JSON</a>, 
                <a href="https://github.com/kevinswiber/siren">SIREN</a> to name a 
                few.
            </p>
            <p>
                backbone.hateoas uses the HAL standard because its JSON format is easy to manipulate with Backbone and 
                because we think its the most used one today.
            </p>
            <p>
                The HAL specification is quickly described here 
                <a href="http://stateless.co/hal_specification.html" target="_blank">HAL - Hypertext Application 
                Language</a>, the JSON version of HAL has also been published as an internet draft here : 
                <a href="https://tools.ietf.org/html/draft-kelly-json-hal-06" target="_blank">JSON Hypertext Application 
                Language</a>.
            </p>
            
            <h2 id="getting-started">Getting started</h2>
            <h3 id="introduction">Introduction</h3>
            <p>
                The HAL standard defines a generic resource concept, but Backbone defines 2 kinds of "resources" (the 
                models and the collections).
            </p>
            <p>
                So backbone.hateoas defines 2 kinds of resources :
            </p>
            <ul>
                <li>
                    The <code>Hal.Model</code> class defines a generic HAL resource and is very similar to the 
                    <code>Backbone.Model</code> class ;
                </li>
                <li>
                    The <code>Hal.Collection</code> class is a specialized HAL resource dedicated to manipulation of 
                    collection resources, this one is a little opinionated (but its design is based on REST API best 
                    practices).
                </li>
            </ul>
            <strong>Hal.Model</strong>
            <p>
                The <code>Hal.Model</code> class extends the <code>Backbone.Model</code> class and adds support to 
                manipulate HAL links and HAL embedded resources.
            </p>
<pre><code class="javascript">
// Instanciation of an Hal.Model object is done the same way as you're used to with a standard Backbone model
var user = new Hal.Model({
    firstName: "John",
    lastName: "Doe",
    _links: {
        avatar: {
            href: "http://localhost/api/users/1/avatar.png" 
        }
    },
    _embedded: {
        address: {
            "city" : "Paris",
            "country" : "France",
            "street" : "142 Rue de Rivoli",
            "zip" : "75001",
            "_links" : {
                "self" : {
                    "href" : "http://localhost/api/addresses/1"
                }
            }
        }
    }
});

// "Direct" properties are accessed using standard Backbone methods
user.get('firstName');
user.get('lastName');

// Getting a link, a link can be manipulated like a Backbone.Model
user.getLink('avatar').get('href');

// Getting an embedded resource, an embedded resource is a Hal.Model
user.getEmbedded('address').get('city');
user.getEmbedded('address').getLink('self').get('href');
</code></pre>
            <p>
                The <code>Hal.Model</code> class has been designed to be very easy to manipulate, we've chosen to create 
                <code>getLink(rel)</code> and <code>getEmbedded(rel)</code> methods to force the developpers to clearly 
                show their intention in the code.
            </p>
            <p>
                For more informations abount the <code>Hal.Model</code> class please read the chapter 
                <a href="#hal.model">Hal.Model</a>.
            </p>
            <strong>Hal.Collection</strong>
            <p>
                The <code>Hal.Collection</code> class extends the <code>Backbone.Collection</code> class by adding 
                utility methods to navigate through an "HAL Collection". The HAL standard does not describe the concept 
                of an HAL collection but most framwork do it (
                <a href="https://apigility.org/documentation/api-primer/halprimer#collections">Apigility</a>, 
                <a href="http://hateoas-php.org/#dealing-with-collections">Willdurand Hateoas</a>, etc.). The 
                <code>Hal.Collection</code> class is configurable and can be used to work with custom pagination 
                parameter names and links.
            </p>
            <p>
                For more informations abount the <code>Hal.Collection</code> class please read the chapter 
                <a href="#hal.model">Hal.Collection</a>.
            </p>
            <h3 id="install">Install</h3>
            <p>
                The easiest way to use the library is to pull it with 
                <a href="http://bower.io" target="_blank">Bower</a> by adding the following dependency inside your 
                <code>bower.json</code> file.
            </p>
<pre><code class="json">{
    "dependencies": {
        "backbone.hateoas" : "~0.1"
    }
}</code></pre>

            <h2>
                Global configuration
            </h2>
            <h3>
                contentType
            </h3>
            <p>
                The HAL standard defines 2 new media types which are <code>application/hal+json</code> and 
                <code>application/hal+xml</code>, it also indicates the following :
            </p>
            <blockquote>
                <p>
                    When serving HAL over HTTP, the Content-Type of the response should contain the relevant media type 
                    name.
                </p>
            </blockquote>
            <p>
                So it defines how the server should respond but is does not define how we should send HTTP POST, PUT and 
                PATCH requests. In fact this is something which seems to be left unspecified deliberatly.
            </p>
            <p>
                The <code>Hal.contentType</code> global configuration parameter allows to configure how your models and 
                collections should be serialized before being sent to the server (i.e it changes the behavior of the 
                Backbone <code><a href="http://backbonejs.org/#Model-toJSON" target="_blank">Model.toJSON()</a></code> 
                and <code><a href="http://backbonejs.org/#Collection-toJSON">Collection.toJSON()</a></code> methods).
            </p>
            <p>
                The current version of the library supports 2 content types : <code>application/json</code> and 
                <code>application/hal+json</code>.
            </p>
            <br/>
            <h4>Sample with <code>application/json</code></h4>
            <p>
                The following sample ...
            </p>
<pre><code class="javascript">// The 'Hal.contentType' parameter is an application wide parameter
// So in most cases it is only configured at one place in your project
Hal.contentType = 'application/json';

...

// Somewhere in the code of the application
var john = new Hal.Model();
john.urlMiddle = 'users';
john.set('id', 'jdoe');
john.fetch({
    success : function() {
        console.log(user.toJSON());     
    }
});
</code></pre>
            <p>
                Will display ...
            </p>
<pre><code class="json">{
    "id": 1,
    "firstName": "John",
    "lastName" : "Doe",
    "address" : {
        "city" : "Paris",
        "country" : "France",
        "street" : "142 Rue de Rivoli",
        "zip" : "75001"
    }
}
</code></pre>
<br/>
            <h4>Sample with <code>application/hal+json</code></h4>
            <p>
                The following sample ...
            </p>
<pre><code class="javascript">// The 'Hal.contentType' parameter is an application wide parameter
// So in most cases it is only configured at one place in your project
Hal.contentType = 'application/hal+json';

...

// Somewhere in the code of the application
var john = new Hal.Model();
john.urlMiddle = 'users';
john.set('id', 'jdoe');
john.fetch({
    success : function() {
        console.log(user.toJSON());     
    }
});
</code></pre>
            <p>
                Will display ...
            </p>
<pre><code class="json">{
    "id": 1,
    "firstName": "John",
    "lastName" : "Doe",
    "_embedded" : {
        "address" : {
            "city" : "Paris",
            "country" : "France",
            "street" : "142 Rue de Rivoli",
            "zip" : "75001",
            "_links" : {
                "self" : {
                    "href" : "http://localhost/backbone.hateoas/test/api/addresses/1"
                }
            }
        }
    },
    "_links" : {
        "address" : {
            "href" : "http://localhost/backbone.hateoas/test/api/addresses/1"
        },
        "self" : { 
            "href" : "http://localhost/backbone.hateoas/test/api/users/1"
        }
    }
}
</code></pre>
            <h3>
                urlRoot
            </h3>
            <p>
                When you work with HAL you often have a root URL which is global to your API, in most cases this URL is 
                the root of a catalog (i.e a special resource describing the documentation of your endpoints and how to 
                access them).
            </p>
            <p>
                The <code>Hal.urlRoot</code> property allows you to configure this global API root URL (please note that 
                the name <code>urlRoot</code> has been chosen to be the same as the Backbone Model <code>urlRoot</code> 
                parameter).
            </p>
            <p>
                For exemple if our API is located at <code>https://myserver.com/api</code> then we could declare the 
                following <code>Hal.urlRoot</code>.
            </p>
<pre><code class="javascript">
Hal.urlRoot = 'https://myserver.com/api';
</code></pre>
            <p>
                After that <code>Hal.Collection</code> and <code>Hal.Model</code> can automatically generate absolute 
                API urls for you.
            </p>
<pre><code class="javascript">
var users = new Hal.Collection();
users.urlMiddle = 'users';

// Fetch 'https://myserver.com/api/users'
users.fetch(); 

// Hal.Model can also be used easily without any associated collection
// This will fetch 'https://myserver.com/api/users/1'
var john = new Hal.Model();
john.urlMiddle = 'users';
john.set('id', 1);
john.fetch();

// If you want you can "force" use of other absolute URLs
// This will fetch 'https://myserver2.com/api/users'
users.url = 'https://myserver2.com/api/users';
users.fetch();

// This will fetch 'https://myserver2.com/api/users/jdoe'
john.urlRoot = 'https://myserver2.com/api/users/jdoe';
john.fetch();
</code></pre>

            <h2>
                Hal.Model
            </h2>
            <h3>
                urlMiddle
            </h3>
            <p>
                The <code>urlMiddle</code> is an additional URL parameter specific to backbone.hateoas and which easier 
                model fetching without being forced to attach your model to a collection.
            </p>
            <p>
                The <code>urlMiddle</code> is used only when your model is not linked to a collection having a URL and 
                which do not define a specific <code>urlRoot</code> property.
            </p>
            <p>
                The <code>urlMiddle</code> is used to create an absolute URL (with the <code>url()</code> method) equal 
                to the concatenation of the <code>Hal.urlRoot</code> property plus the <code>urlMiddle</code>.
            </p>
            <p>
                Here is an exemple :
            </p>
<pre><code class="javascript">
Hal.urlRoot = 'https://myserver.com/api';

// This will fetch 'https://myserver.com/api/users/1'
var john = new Hal.Model();
john.urlMiddle = 'users';
john.set('id', 1);
john.fetch();

// This will fetch 'https://myserver.com/api/companies/2/users/1'
john = new Hal.Model();
john.urlMiddle = 'companies/2/users';
john.set('id', 1);
john.fetch();
</code></pre>

            <h3>
                toJSON
            </h3>
            <p>
                By default the Backbone <code>toJSON([options])</code> method do not accept or use any option, a 
                <code>Hal.Model</code> can use an additional <code>contentType</code> option which can be equal to 
                <code>application/json</code> or <code>application/hal+json</code>.
            </p>
            <p>
                When the <code>toJSON([options])</code> method is called with this option it overwrites the 
                <code>Hal.contentType</code> configuration only for this call.
            </p>
            <p>
                In most cases this is useful when you when to store a serialized version of a resource somewhere (in the 
                local storage for example).
            </p>
            
            <h2>
                Hal.Collection
            </h2>
            <p>
                The backbone.hateoas <code>Hal.Collection</code> class is an opinionated class to manipulate HAL 
                collection resources, what we call a HAL collection is a resource having the following structure :
            </p>
<pre><code class="json">
{
    "page" : 1, 
    "page_count" : 6,
    "page_size" : 12,
    "total_items" : 65,
    "_links" : {
        "self" : {
            "href" : "http://myserver.com/api/users?page=3"
        },
        "first" : {
            "href" : "http://myserver.com/api/users?page=1"
        },
        "last" : {
            "href" : "http://myserver.com/api/users?page=133"
        },
        "previous" : {
            "href" : "http://myserver.com/api/users?page=2"
        },
        "next" : {
            "href" : "http://myserver.com/api/users?page=4"
        } 
    },
    "_embedded" : {
        "users" : [
            { ... },
            { ... },
            ...
        ]
    }
}
</code></pre>
            <p>
                The constraints imposed to have a valid HAL Collection are the following :
            </p>
            <ul>
                <li>The HAL resource MUST HAVE a page property (or index)</li>
                <li>The HAL resource MUST HAVE a number of pages (or page count) property</li>
                <li>The HAL resource MUST HAVE a page size property</li>
                <li>The HAL resource MUST HAVE a total number of results property</li>
                <li>The HAL resource MUST HAVE ONLY ONE embedded array property representing the elements of the current 
                collection's page</li>
            </ul>
            <p>
                So a <code>Hal.Collection</code> object automatically manages paginated collections, the name of the 
                attributes <code>page</code>, <code>page_count</code>, <code>page_size</code> and 
                <code>total_items</code> have been chosen to be compliant with 
                <a href="https://apigility.org/">Apigility</a>.
            </p>
<pre><code class="javascript">
var UserCollection = Hal.Collection.extend({
    model : function(attrs, options) {
        if(attrs.type === 'STUDENT') {

            return new Student(attrs);

        } else if(attrs.type === 'TEACHER') {

            return new Teacher(attrs);

        }
    }, 
    rel : 'users', 
    url : 'http://myserver.com/api/users'
});
var users = new UserCollection();
users.getFirstPage();
users.getLastPage();
users.getPreviousPage();
users.getNextPage();
</code></pre>

            <h2>
                Embedded
            </h2>
            
            <h2>
                Links
            </h2>
            
            <h2>
                Release history
            </h2>
	    </div>
    </div>
</div>
